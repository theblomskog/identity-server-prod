using System;
using System.Collections.Generic;
using System.IdentityModel.Tokens.Jwt;
using System.Linq;
using System.Net.Http;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Net.Http.Headers;
using Flurl;
using Flurl.Http;
using IdentityModel.Client;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using OpenID_Connect_client.Models;

namespace OpenID_Connect_client.Controllers
{
    public class AuthCodeController : Controller
    {
        private readonly IOpenIDSettings _openIdSettings;
        private static string code_verifier;
        private static string clientID;
        private static string redirectUrl;
        private static string scope;
        private string tokenIntrospectionClientId;
        private string tokenIntrospectionClientSecret;

        public AuthCodeController(IOpenIDSettings openIdSettings)
        {
            _openIdSettings = openIdSettings;

            clientID = "authcodeflowclient_dev";
            redirectUrl = "https://localhost:8001/authcode/callback";
            scope = "openid email idresource1 apiscope1 payment";

            //For the request to the token introspection endpoint (Should be the ApiResource name and secret here)
            tokenIntrospectionClientId = "paymentapi";
            tokenIntrospectionClientSecret = "myapisecret";
        }

        public IActionResult Index()
        {
            string url = BuildLoginUrl(clientID);
            ViewData["loginurl"] = url;

            return View();
        }


        /// <summary>
        /// This method is called with the authorization code and state parameter
        /// </summary>
        /// <param name="code">authorization code generated by the authorization server. This code is relatively short-lived, typically lasting between 1 to 10 minutes depending on the OAuth service.</param>
        /// <param name="state"></param>
        /// <returns></returns>
        [HttpPost]
        public IActionResult Callback(string code, string state)
        {
            //To be secure then the state parameter should be compared to the state sent in the previous step
            if (code != null)
            {

                var url = new Url(_openIdSettings.token_endpoint);

                var token = url.PostUrlEncodedAsync(new
                {
                    client_id = clientID,       //Id of this client
                    client_secret = "mysecret",
                    grant_type = "authorization_code",
                    code_verifier = code_verifier,
                    code = code,
                    redirect_uri = redirectUrl

                }).ReceiveJson<Token>().Result;


                string accessToken = token.access_token;
                string idToken = token.id_token;


                JwtSecurityTokenHandler handler = new JwtSecurityTokenHandler();

                JwtSecurityToken accessTokenObj = handler.ReadJwtToken(accessToken);
                JwtSecurityToken idTokenObj = handler.ReadJwtToken(idToken);

                ViewData["accessTokenObj"] = accessTokenObj.Payload;
                ViewData["idTokenObj"] = idTokenObj.Payload;

                var tokenIntrospectionData = GetTokenIntrospectionData(accessToken);
                var userInfoData = GetUserInfoData(accessToken);

                ViewData["tokenIntrospection"] = JToken.Parse(tokenIntrospectionData).ToString(Formatting.Indented);
                ViewData["userInfo"] = JToken.Parse(userInfoData).ToString(Formatting.Indented);

                ViewData["scope"] = scope;

                return View(token);
            }
            else
            {
                var token = new Token();
                ViewData["userInfo"] = "";
                ViewData["tokenIntrospection"] = "";
                   
                return View(token);
            }

        }


        private string GetTokenIntrospectionData(string accessToken)
        {
            var client = new HttpClient();

            var request = new TokenIntrospectionRequest
            {
                //The introspection endpoint requires authentication - since the client of an introspection endpoint is an API, you configure the secret on the ApiResource.
                Address = _openIdSettings.introspection_endpoint,
                
                ClientId = tokenIntrospectionClientId,
                ClientSecret = tokenIntrospectionClientSecret,

                Token = accessToken
            };

            TokenIntrospectionResponse response = client.IntrospectTokenAsync(request).Result;

            string data = response.Raw;
            if (data.Length == 0)
                data = "{}"; //Empty json to prevent errors

            return data;
        }


        private string GetUserInfoData(string accessToken)
        {
            var client = new HttpClient();

            var request = new UserInfoRequest
            {
                Address = _openIdSettings.userinfo_endpoint,
                Token = accessToken,
            };

            UserInfoResponse response = client.GetUserInfoAsync(request).Result;
            return response.Raw;
        }

        /// <summary>
        /// Construct the login URL
        /// </summary>
        /// <returns></returns>
        private string BuildLoginUrl(string clientID)
        {
            //In real life, nonce and state should be random values, but we hardcoded them here for simplicity
            string nonceValue = "1122334455";
            string stateValue = "9988776655";

   
            string redirectUrl = "https://localhost:8001/authcode/callback";

            var url = new Url(_openIdSettings.authorization_endpoint);

            code_verifier = CalculateCryptographicRandomString(43);

           ViewData["scope"] = scope;


            url = url.SetQueryParams(new
            {
                response_type = "code",       //Get both access-token + ID-token
                client_id = clientID,       //Id of this client

                scope = scope,  

                code_challenge = CalculateSha256(code_verifier),    //Add the PKCE headers
                code_challenge_method = "S256",

                prompt = "consent",                     // Force users to provide consent
                response_mode = "form_post",            // Send the token response as a form post instead of a fragment encoded redirect

                state = stateValue,                     // To prevent CSRF attacks
                nonce = nonceValue,                     // To further strengthen the security

                redirect_uri = redirectUrl              // The URL to which the IdentityServer will redirect the user's browser after authorization has been granted by the user. 
            });


            return url.ToString();
        }


        public string CalculateSha256(string input)
        {
            using (var sha = SHA256.Create())
            {
                var bytes = Encoding.UTF8.GetBytes(input);
                var hash = sha.ComputeHash(bytes);

                return base64urlencode(hash);
            }
        }

        private string base64urlencode(byte[] arg)
        {
            string s = Convert.ToBase64String(arg); // Regular base64 encoder
            s = s.Split('=')[0]; // Remove any trailing '='s
            s = s.Replace('+', '-'); // 62nd char of encoding
            s = s.Replace('/', '_'); // 63rd char of encoding
            return s;
        }


        private string CalculateCryptographicRandomString(int maxSize)
        {
            char[] chars = new char[62];
            chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890".ToCharArray();

            RNGCryptoServiceProvider crypto = new RNGCryptoServiceProvider();
            var data = new byte[maxSize];
            crypto.GetNonZeroBytes(data);

            StringBuilder result = new StringBuilder(maxSize);
            foreach (byte b in data)
            {
                result.Append(chars[b % (chars.Length - 1)]);
            }
            return result.ToString();
        }
    }
}
